---
alwaysApply: true
---
# AI 开发行为规范

## 介绍

`cursor.rules`文档概述了约束AI行为的规则，确保AI不会在没有用户明确指示的情况下执行不必要的操作，
尤其是在处理数据和前端行为时。目标是保持清晰、精确，并避免在实现过程中引入不必要的复杂性或错误。
以下是一些关键规则。

## 1. 前端排序 vs 后端排序

- **规则**：不要在排序表格数据时自动应用前端排序。
- **原因**：对于大数据集来说，前端排序效率低下，可能导致数据呈现不一致。通常，排序应由后端处理，这样可以更高效且准确地完成。
- **实现**：
  - 除非用户明确要求前端排序，否则应始终使用后端排序。
  - 只有在数据较小且用户明确要求的情况下，才考虑前端排序。



## 2. 数据监控约束
### 避免过度监控：
- 禁止使用watch监控是否点击相同数据项
- 避免通过ID比较来阻止数据更新
- 不要假设"相同数据不需要刷新"

### 正确模式：
- 每次点击详情都应触发数据更新
- 使用forceUpdate标志或时间戳确保刷新
- 保持数据获取逻辑的幂等性

### 禁止模式示例：
```javascript
// ❌ 禁止这样做
watch(currentId, (newVal, oldVal) => {
  if (newVal === oldVal) return // 这会导致数据不更新
  fetchData()
})
```
## 3. 数值计算精度约束
### 精度处理原则：所有加减乘除计算必须考虑JavaScript浮点数精度问题

### 禁止直接使用 + - * / 要进行精确计算
- 强制使用工具库：使用 Decimal.js、BigNumber.js 或 number-precision 等精度库
- 或实现安全的四则运算工具函数

### 正确模式示例：
```javascript
// ✅ 必须这样做
import { Decimal } from 'decimal.js'

// 计算
const total = new Decimal(0.1).plus(0.2).toNumber() // 0.3

// 或使用工具函数
function safeAdd(a, b) {
  const multiplier = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b)))
  return (a * multiplier + b * multiplier) / multiplier
}
```

### 禁止模式示例：
```javascript
// ❌ 绝对禁止
const total = 0.1 + 0.2 // 结果是 0.30000000000000004

// ❌ 禁止使用原生计算
const price = 19.9 * 3 // 可能产生精度问题
```
## 4. 数据转换类型兼容

- 在判断条件类似这种number和string,例如：0或者“0”，由于不能确定后端接口返回的数据类型是数字还是字符串，在写js数据判断时尽量不要采用“===”，请使用“==”
- 表单回填要做好数字类型和字符串类型的兼容

## 业务规则
- 在金融行业，null、undefined是代表没有数据，应该转换成""，而不是"0",0会让用户误以为数值是0
## 功能扩展原则
### 最小实现原则：
- 严格按需求文档实现功能
- 不添加"可能有用"的额外功能
- 如需优化，必须先与用户确认

### 假设管理：
- 不假设用户的使用习惯
- 不根据"常见做法"偏离需求
- 所有偏离必须有明确依据

## 数据获取规范
始终新鲜：每次用户操作都应获取最新数据
避免缓存假设：不要假设数据不需要重新获取
明确刷新策略：在代码中添加注释说明刷新逻辑

## 沟通与确认
当遇到以下情况时，必须暂停并询问：
需求不明确但可能影响架构的选择
发现潜在优化但与当前需求不符
需要添加超出明确需求的功能
涉及数值计算的精度处理方案

## 代码注释要求

在实现可能引起误解的功能时，必须添加说明注释：
// 规则依据：用户明确要求前端排序（需求文档第X条）
// 注意：仅适用于XXX场景，数据量限制：XXX
// 精度处理：使用Decimal.js确保计算准确（财务场景必需）
// 参考：cursor.rules 第3节 - 数值计算精度约束

## 特殊场景处理
数据计算：必须使用高精度计算库
价格计算：保留指定位数小数，使用银行家舍入法
百分比计算：注意除以100的精度问题
大数据量统计：分批计算避免精度累积误差

## 违规示例
❌ 错误做法：
"我猜用户可能也需要前端排序，一并实现了吧"
"点击相同行就不刷新了，提高性能"
"这个表格加个拖拽排序，很实用"
"直接使用 0.1 + 0.2，应该没问题"
"价格计算直接用乘法，差几分钱没关系"
✅ 正确做法：
"按需求文档，排序由后端API实现"
"每次行点击都调用API获取最新数据"
"严格按需求实现，不添加未要求的功能"
"使用Decimal.js进行价格计算，确保精度"
"数值计算已添加精度处理，符合财务要求"

## 规则核心：

做需求明确要求的事，不做你认为"更好"的事
所有优化和扩展必须先确认后实施
数值计算必须处理精度问题，特别是财务场景
保持代码的准确性和可预测性高于"智能"假设
